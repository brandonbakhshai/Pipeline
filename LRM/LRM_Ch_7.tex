\documentclass[./LRM_main.tex]{subfiles}
\begin{comment}
If you want a box around your answer and that answer is an
equation then use \boxed{$$ equation $$} 

if you want to indent a block of text:
\begin{adjustwidth}{cm of right indent}{cm of left indent}
% paragraph to be indented
\end{adjustwidth}

if you just want one indent for one line 
use \indent per intended indent per line

A sections numbers automatically, so if the number of 
the problem is out of order it would be easier to 
just indent and bold the sections and subsections
and not use the \section{} kind of commands

\newpage makes a new page

$normal math mode$
$$Special math mode$$

to include an image use
\includegraphics{image_name}
image_name is the file name (.png) without the extension. The file
name cannot have any spaces or any periods other than the one before
the file extension.

To include a codeblock use
\begin{lstlisting}
ExampleCode(blah, blah)
{
	it does tabbing and everything;
	for (coloring of major languages like java){
		add the folloing to the \lstset tuple:
			language=<name_of_language>;
	}
}
\end{lstlisting}

\end{comment}


\begin{document}

%\tableofcontents

%\thispagestyle{empty}
%\newpage
% If you want to change how the subsubsection's are numbered
%\renewcommand{\thesubsection}{\thesection.\alph{subsection}.} 

%\setcounter{page}{0}
\chapter{Asynchronous Programming with Pipeline}
Async control flow is incredibly useful when dealing with I/O operations, which are the foundation of web-based programming. When restricted to a single-threaded and single-process model, I/O operations in a programming language are blocking forcing the program to wait for a potentially unbounded time. Introduce multi-threading or multi-process models, and a programming language becomes much more complex. The single-threaded asynchronous control flow model simplifies dealing with I/O operations such that the program does not.


\section{My First Pipeline}
Consider the following example pipeline:

\begin{lstlisting}
pipe {
	tuple a0 = readFile("/home/user/you/data.txt"); 
 	tuple a1 = processData(a); 
	saveProcessedData(a1, "/home/user/you/processedData.txt";
} catch(String functionName, String kindOfError, String errorMessage) {
    printf("%s resulted in the following error:\n%s - %s", functionName, kindOfError, errorMessage);
}
\end{lstlisting}
Formally, the definition of a pipeline is as such:
\begin{lstlisting}
pipe {
	tuple a0 = function0(Type param0, ..., Type paramN); 
	tuple a1 = function1(a0, Type param0, ..., Type paramN); 
	tuple a2 = function2(a1, Type param0, ..., Type paramN);
	... 
	functionN(anminus1, Type param0, ..., Type paramN)
} catch(String functionName, String kindOfError, String errorMessage) {
    ...
}
\end{lstlisting}
How to interpret the above:\\
\begin{itemize}
    \item \textit{Type} references some actual type.\\
    \item \textit{Type param1, ..., Type paramN} references some (potentially zero-length) sequence of parameters to a function.\\
    \item \textit{tuple ax} is a tuple holding the results of the corresponding function, which can be used by the next function in sequence.\\\\
\end{itemize}
The catch statement is not intended to catch responses to blocking calls that are technically valid but not what the programmer wants. Consider a Stripe API call which returns a valid response
containing a "card declined" error message. This should be dealt with using a conditional within the function that made that call. The proper use for the catch statement would be, for example,
when a function makes a blocking database call to a database that does not exist or refuses connection. Essentially, the catch statement is for unrecoverable errors, as in Java.\\\\
Note: It's extremely important for the programmer to understand the code within the curly brackets above would not run the way it should if it were placed outside a pipeline. Because any of the functions
may be blocking, if they are not placed in a pipeline, the main thread will not wait for the function to return, so any code immediately after \textit{tuple a0 = function0(Type param0, ..., Type
paramN);} that makes use of variable \textit{a0} could be reading a null or junk value. Blocking functions must be placed within pipelines, which will handle the control flow so that blocking functions must return before subsequent code runs.
\section{And Then There Were Two}
Consider the terms \textit{pipelineX} to refer to a sequence of functions arranged in a pipeline as detailed in the section \textit{My First Pipeline}, where X is a number serving as a unique ID for
the pipeline. Now consider the two distinct pipelines, \textit{pipeline0} and \textit{pipeline1}. Both pipelines contain functions which are blocking, waiting for the results of an I/O operation. The two pipelines are arranged as such in code:
\begin{lstlisting}
pipeline0;
pipeline1;
\end{lstlisting}
Let's mimic the flow of a real program as it executes the two lines above. \textit{Pipeline0} is executed and runs until there is a blocking operation. As soon as a blocking operation is encountered,
the program moves it off of the main thread, and then on the main thread continues on to execute \textit{pipeline1}. The functions in pipeline1 will execute until one blocks, at which point this pipeline1 will also be queued and moved off the main thread. The main thread will continue executing any code after pipeline1. When the blocking function in pipeline0 or pipeline1 returns, the corresponding pipeline resumes execution.   


\section{Data and Pipelines}
If there is a blocking I/O operation, it must be put in a pipeline or the return value for the blocking function may be filled with junk or a null value, and this erroneous value could be used immediately if the next line makes use of the variable. Pipelines should be treated as islands of data, in that functions which depend on (take as arguments) values returned from blocking functions can only execute after the blocking function returns, which is unpredictable. In that sense, functions that are data dependent and relate to a particular instance or type of I/O operation should likely be encapsulated in a single pipeline. 

\section{Grammars}
\begin{lstlisting}
pipe-statement:
	pipe { statement-list }
	pipe { statement-list } catch( parameter-list ) { statement-list }

statement-list:
    statement
    statement statement-list
\end{lstlisting}


\end{document}

